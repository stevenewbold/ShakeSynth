#! /Applications/Nuke15.0v1/Nuke15.0v1.app/Contents/MacOS/libnuke-15.0.1.dylib -nx
version 15.0 v1
Gizmo {
 addUserKnob {20 User l ShakeSynth}
 addUserKnob {6 firstRun l "" +STARTLINE +INVISIBLE +STARTLINE}
 addUserKnob {2 profilePath l "" +STARTLINE +INVISIBLE}
 profilePath /Users/stephennewbold/.nuke/ShakeSynth/profiles
 addUserKnob {4 profiles t "Displays the current list of profiles installed in the /profiles/ directory in the same location as the ShakeSynth.gizmo file." M {blank impact_decay_v001 impact_kick_v001 impact_sharp_v001 impact_sharp_v002 impact_thud_v001 mechanical_jitter rumble_v001 shake_hardmount_v001 underwater_current_200f vibration_mechanical_v001 vibration_mechanical_v002 vibration_mechanical_v003 ""}}
 addUserKnob {22 loadProfile l "load profile" t "Load the profile listed in the drop down menu. Note:- this will restore controls to the profile defaults." -STARTLINE T "import nuke\nimport os\n\nnode = nuke.thisNode()\n\n# Directory + selected profile\ndirectory = node\[\"profilePath\"].getValue()\nprofile = node\[\"profiles\"].value()\nfilepath = os.path.join(directory, profile + \".shk\")\n\nif not os.path.isfile(filepath):\n    nuke.message(\"Profile file not found:\\n\{\}\".format(filepath))\n    raise ValueError(\"Missing .shk file\")\n\n##############################################\n# Read metadata + shake curves\n##############################################\n\nampX = ampY = ampR = 0.0\nenableXLow = enableYLow = enableRLow = enableXMid = enableYMid = enableRMid = enableXHigh = enableYHigh = enableRHigh = False\nxLowAmp = yLowAmp = rLowAmp = xMidAmp = yMidAmp = rMidAmp = xHighAmp = yHighAmp = rHighAmp = 1.0\ncurve_data = \[]\n\nwith open(filepath, \"r\") as f:\n    for line in f:\n        line = line.strip()\n        if not line:\n            continue\n\n        if line.startswith(\"# ampX=\"):\n            ampX = float(line.split(\"=\")\[1])\n            continue\n        if line.startswith(\"# ampY=\"):\n            ampY = float(line.split(\"=\")\[1])\n            continue\n        if line.startswith(\"# ampR=\"):\n            ampR = float(line.split(\"=\")\[1])\n            continue\n\n        if line.startswith(\"# xLowMult=\"):\n           xLowAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# yLowMult=\"):\n           yLowAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# rotLowMult=\"):\n           rLowAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# xMidMult=\"):\n           xMidAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# yMidMult=\"):\n           yMidAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# rotMidMult=\"):\n           rMidAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# xHighMult=\"):\n           xHighAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# yHighMult=\"):\n           yHighAmp = float(line.split(\"=\")\[1])\n           continue\n        if line.startswith(\"# rotHighMult=\"):\n           rHighAmp = float(line.split(\"=\")\[1])\n           continue\n\n        if line.startswith(\"# enableXLow=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableXLow = value == \"true\"\n        if line.startswith(\"# enableXMid=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableXMid = value == \"true\"\n        if line.startswith(\"# enableXHigh=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableXHigh = value == \"true\"\n        if line.startswith(\"# enableYLow=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableYLow = value == \"true\"\n        if line.startswith(\"# enableYMid=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableYMid= value == \"true\"\n        if line.startswith(\"# enableYHigh=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableYHigh= value == \"true\"\n        if line.startswith(\"# enableRotLow=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableRLow = value == \"true\"\n        if line.startswith(\"# enableRotMid=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableRMid= value == \"true\"\n        if line.startswith(\"# enableRotHigh=\"):\n            value = line.split(\"=\", 1)\[1].strip().lower()\n            enableRHigh = value == \"true\"\n\n        if line.startswith(\"#\"):\n            continue\n\n        if line.startswith(\"frame,\"):\n            continue\n\n        cols = line.split(\",\")\n        if len(cols) != 10:\n            continue\n\n        frame = float(cols\[0])\n        values = list(map(float, cols\[1:]))\n        curve_data.append((frame, values))\n\n##############################################\n# Assign amplitude values\n##############################################\n\nnode\[\"xEnableLow\"].setValue(enableXLow)\nnode\[\"xEnableMid\"].setValue(enableXMid)\nnode\[\"xEnableHigh\"].setValue(enableXHigh)\n\nnode\[\"yEnableLow\"].setValue(enableYLow)\nnode\[\"yEnableMid\"].setValue(enableYMid)\nnode\[\"yEnableHigh\"].setValue(enableYHigh)\n\nnode\[\"rotEnableLow\"].setValue(enableRLow)\nnode\[\"rotEnableMid\"].setValue(enableRMid)\nnode\[\"rotEnableHigh\"].setValue(enableRHigh)\n\nnode\['xLowAmp'].setValue(xLowAmp)\nnode\['yLowAmp'].setValue(yLowAmp)\nnode\['rotLowAmp'].setValue(rLowAmp)\n\nnode\['xMidAmp'].setValue(xMidAmp)\nnode\['yMidAmp'].setValue(yMidAmp)\nnode\['rotMidAmp'].setValue(rMidAmp)\n\nnode\['xHighAmp'].setValue(xHighAmp)\nnode\['yHighAmp'].setValue(yHighAmp)\nnode\['rotHighAmp'].setValue(rHighAmp)\n\n##############################################\n# Assign frequency values\n##############################################\n\nnode\[\"xAmpRaw\"].setValue(ampX)\nnode\[\"yAmpRaw\"].setValue(ampY)\nnode\[\"rotAmpRaw\"].setValue(ampR)\n\n##############################################\n# Animation curve generation\n##############################################\n\ncurve_map = \{\n    0: \"xLowRaw\",\n    1: \"xMidRaw\",\n    2: \"xHighRaw\",\n    3: \"yLowRaw\",\n    4: \"yMidRaw\",\n    5: \"yHighRaw\",\n    6: \"rotLowRaw\",\n    7: \"rotMidRaw\",\n    8: \"rotHighRaw\"\n\}\n\n# Reset and populate curves\nfor idx, knob_name in curve_map.items():\n    knob = node\[knob_name]\n\n    # Clear any previous animation\n    knob.clearAnimated()\n    knob.setAnimated()\n\n    # Add keys using setValueAt (most reliable method)\n    for frame, vals in curve_data:\n        knob.setValueAt(vals\[idx], frame)\n\nif not curve_data:\n    info_text = \"No frame data loaded.\"\nelse:\n    frames = \[f for f, _ in curve_data]\n\n    first_frame = int(round(min(frames)))\n    last_frame  = int(round(max(frames)))\n    frame_count = last_frame - first_frame + 1\n\n    info_text = (\n        \"                      loaded profile: \{\}\\n\"\n        \"                      frames: \{\} – \{\}\"\n        \"   total frames: \{\}\"\n    ).format(profile, first_frame, last_frame, frame_count)\n\nnode\[\"profileInfo\"].setValue(info_text)\nnode\[\"profileInfo\"].setFlag(nuke.STARTLINE)\nnode\[\"profileInfo\"].setEnabled(False)\n\n"}
 addUserKnob {22 refreshProfiles l "refresh profiles" t "load profiles that live in the correct location" -STARTLINE T "import nuke\nimport os\n\n##############################################\n# VALIDATION FUNCTION (self-contained)\n##############################################\n\ndef validate_shk_file(path):\n    \"\"\"\n    Returns True if the file is a valid Shake-style .shk file.\n    \"\"\"\n    try:\n        with open(path, \"r\") as f:\n            lines = \[l.strip() for l in f.readlines() if l.strip()]\n\n        if not lines:\n            return False\n\n        # Find header row (skip comment metadata)\n        header = None\n        for l in lines:\n            if not l.startswith(\"#\"):\n                header = l\n                break\n\n        if header != \"frame,xLow,xMid,xHigh,yLow,yMid,yHigh,rotationLow,rotationMid,rotationHigh\":\n            return False\n\n        header_index = lines.index(header)\n        data_lines = lines\[header_index + 1:]\n        if not data_lines:\n            return False\n\n        last_frame = None\n\n        for line in data_lines:\n            cols = line.split(\",\")\n            if len(cols) != 10:\n                return False\n\n            try:\n                frame,xLow,xMid,xHigh,yLow,yMid,yHigh,rotationLow,rotationMid,rotationHigh = map(float, cols)\n            except:\n                return False\n\n            \n        return True\n\n    except Exception:\n        return False\n\n\n##############################################\n# MAIN EXECUTION\n##############################################\n\nnode = nuke.thisNode()\n\nprofiles_dir = None\n\nfor p in nuke.pluginPath():\n    if not os.path.isfile(os.path.join(p, \"ShakeSynth.gizmo\")):\n        continue\n\n\n    test = os.path.join(p, \"profiles\")\n    if os.path.isdir(test):\n        print(test)\n        profiles_dir = test\n        break\n\ndirectory = profiles_dir\nnode\[\"profilePath\"].setText(directory)\n\nif not os.path.isdir(directory):\n    nuke.message(\"Directory does not exist:\\n\{\}\".format(directory))\n    raise ValueError(\"Invalid directory\")\n\nvalid_profiles = \[]\n\nfor filename in os.listdir(directory):\n    if filename.lower().endswith(\".shk\"):\n        fullpath = os.path.join(directory, filename)\n\n        if validate_shk_file(fullpath):\n            # strip extension\n            name = os.path.splitext(filename)\[0]\n            valid_profiles.append(name)\n\nif not valid_profiles:\n    nuke.message(\"No valid .shk files found in:\\n\{\}\".format(directory))\n    node\[\"profiles\"].setValues(\[])\n    raise ValueError(\"No valid profiles\")\n\n# Populate dropdown\nvalid_profiles.sort()\nnode\[\"profiles\"].setValues(valid_profiles)\n\n# Select first item by default\n# node\[\"profiles\"].setValue(valid_profiles\[0])\n\n"}
 addUserKnob {26 profileInfo l "" +STARTLINE +DISABLED T "                      loaded profile: blank\n                      frames: 1001 – 1001   total frames: 1"}
 addUserKnob {26 ""}
 addUserKnob {20 previewGroup l preview n 1}
 previewGroup 0
 addUserKnob {6 preview t "View a checkboard to preview the current camera shake." +STARTLINE}
 preview true
 addUserKnob {41 boxsize l "checkerboard size" t "The size of the checkerboard" T CheckerBoard1.boxsize}
 addUserKnob {41 format l "preview format" t "The format of the checkboard preview" T CheckerBoard1.format}
 addUserKnob {20 endGroup_7 n -1}
 addUserKnob {26 ""}
 addUserKnob {20 amplitude n 1}
 addUserKnob {7 xAmpRaw l "x (px)" t "The global amplitude of the shake in horizontal direction in pixels" R 0 50}
 xAmpRaw 20
 addUserKnob {7 yAmpRaw l "y (px)" t "The global amplitude of the shake in vertical direction in pixels" R 0 50}
 yAmpRaw 20
 addUserKnob {7 rotAmpRaw l "rotation (deg)" t "The global maximum amount of rotation" R 0 10}
 rotAmpRaw 1
 addUserKnob {20 endGroup_4 n -1}
 addUserKnob {26 ""}
 addUserKnob {20 frequencies l "frequency controls" n 1}
 frequencies 0
 addUserKnob {26 textBands l "" +STARTLINE T ""}
 addUserKnob {26 textLow l "<b>low band<b>"}
 addUserKnob {7 xLowAmp l "x multiplier" t "Fine control over the low frequency of the current profile" R 0 4}
 xLowAmp 1
 addUserKnob {6 xEnableLow l enable -STARTLINE}
 xEnableLow true
 addUserKnob {7 yLowAmp l "y multiplier" t "Fine control over the low frequency of the current profile" R 0 4}
 yLowAmp 1
 addUserKnob {6 yEnableLow l enable -STARTLINE}
 yEnableLow true
 addUserKnob {7 rotLowAmp l "rotation multiplier" t "Fine control over the low frequency of the current profile" R 0 4}
 rotLowAmp 1
 addUserKnob {6 rotEnableLow l enable -STARTLINE}
 rotEnableLow true
 addUserKnob {26 textMid l "<b>mid band<b>"}
 addUserKnob {7 xMidAmp l "x multiplier" t "Fine control over the mid frequency of the current profile" R 0 4}
 xMidAmp 1
 addUserKnob {6 xEnableMid l enable -STARTLINE}
 xEnableMid true
 addUserKnob {7 yMidAmp l "y multiplier" t "Fine control over the mid frequency of the current profile" R 0 4}
 yMidAmp 1
 addUserKnob {6 yEnableMid l enable -STARTLINE}
 yEnableMid true
 addUserKnob {7 rotMidAmp l "rotation multiplier" t "Fine control over the mid frequency of the current profile" R 0 4}
 rotMidAmp 1
 addUserKnob {6 rotEnableMid l enable -STARTLINE}
 rotEnableMid true
 addUserKnob {26 textHigh l "<b>high band<b>"}
 addUserKnob {7 xHighAmp l "x multiplier" t "Fine control over the high frequency of the current profile" R 0 4}
 xHighAmp 1
 addUserKnob {6 xEnableHigh l enable -STARTLINE}
 xEnableHigh true
 addUserKnob {7 yHighAmp l "y multiplier" t "Fine control over the high frequency of the current profile" R 0 4}
 yHighAmp 1
 addUserKnob {6 yEnableHigh l enable -STARTLINE}
 yEnableHigh true
 addUserKnob {7 rotHighAmp l "rotation multiplier" t "Fine control over the high frequency of the current profile" R 0 4}
 rotHighAmp 1
 addUserKnob {6 rotEnableHigh l enable -STARTLINE}
 rotEnableHigh true
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 ""}
 addUserKnob {20 offsets l "curve offsets" n 1}
 offsets 0
 addUserKnob {7 curveScale l speed t "The speed of the curve.  Values below 1 slow the shake, values above 1 will speed up the shake." R 0 10}
 curveScale 1
 addUserKnob {3 pivotFrame l pivot t "This frame stays constant when adjusting the speed of the shake" -STARTLINE}
 pivotFrame 1001
 addUserKnob {7 scaledFrame +INVISIBLE}
 scaledFrame {{"pivotFrame + (frame - pivotFrame) * curveScale" i}}
 addUserKnob {7 timeOffset l "x (time)" t "shift the camerashake back or forth in time" R -50 50}
 addUserKnob {7 baseline l "y (baseline)" t "adjust the global center point of the camera shake.  This can be useful if the captured profile is asymetric and needs balancing." R -10 10}
 addUserKnob {20 endGroup_6 n -1}
 addUserKnob {26 ""}
 addUserKnob {20 postScale l "post scale" n 1}
 postScale 0
 addUserKnob {22 calcMaxButton l "calculate current max" t "Use this button to attempt to calculate how much scale is required to cover the current settings.\n\nMake sure to adjust this after large changes to amplitudes." -STARTLINE T "import nuke\nimport math\n\nnode = nuke.thisNode()\n\n##############################################\n# Get frame range based on raw animation\n##############################################\n\n# All raw knobs have the same frame range\nraw_knob = node\[\"xLowRaw\"]\ncurve = raw_knob.animation(0)\nframes = \[k.x for k in curve.keys()]\n\nif not frames:\n    nuke.message(\"No animation data exists\")\n    raise ValueError(\"No animation\")\n\nfirst = int(min(frames))\nlast  = int(max(frames))\n\n##############################################\n# Helper to evaluate a knob at a frame\n##############################################\n\ndef val(knob_name, frame):\n    k = node\[knob_name]\n    if k.isAnimated():\n        return k.getValueAt(frame)\n    return k.value()\n\n##############################################\n# Get static raw amplitudes\n##############################################\n\nxAmpRaw  = node\[\"xAmpRaw\"].value()\nyAmpRaw  = node\[\"yAmpRaw\"].value()\nrotAmpRaw = node\[\"rotAmpRaw\"].value()\n\n##############################################\n# Max trackers\n##############################################\n\nmaxX = 0.0\nmaxY = 0.0\nmaxRot = 0.0\n\n##############################################\n# Frame-by-frame evaluation\n##############################################\n\nfor f in range(first, last + 1):\n\n    # X\n    xVal = xAmpRaw * (\n        (val(\"xLowRaw\",  f) * val(\"xLowAmp\",  f) if node\[\"xEnableLow\"].value()  else 0.0) +\n        (val(\"xMidRaw\",  f) * val(\"xMidAmp\",  f) if node\[\"xEnableMid\"].value()  else 0.0) +\n        (val(\"xHighRaw\", f) * val(\"xHighAmp\", f) if node\[\"xEnableHigh\"].value() else 0.0)\n    )\n\n    # Y\n    yVal = yAmpRaw * (\n        (val(\"yLowRaw\",  f) * val(\"yLowAmp\",  f) if node\[\"yEnableLow\"].value()  else 0.0) +\n        (val(\"yMidRaw\",  f) * val(\"yMidAmp\",  f) if node\[\"yEnableMid\"].value()  else 0.0) +\n        (val(\"yHighRaw\", f) * val(\"yHighAmp\", f) if node\[\"yEnableHigh\"].value() else 0.0)\n    )\n\n    # Rotation\n    rotVal = rotAmpRaw * (\n        (val(\"rotLowRaw\",  f) * val(\"rotLowAmp\",  f) if node\[\"rotEnableLow\"].value()  else 0.0) +\n        (val(\"rotMidRaw\",  f) * val(\"rotMidAmp\",  f) if node\[\"rotEnableMid\"].value()  else 0.0) +\n        (val(\"rotHighRaw\", f) * val(\"rotHighAmp\", f) if node\[\"rotEnableHigh\"].value() else 0.0)\n    )\n\n    # Track absolute maxima\n    if abs(xVal) > abs(maxX):\n        maxX = abs(xVal)\n\n    if abs(yVal) > abs(maxY):\n        maxY = abs(yVal)\n\n    if abs(rotVal) > abs(maxRot):\n        maxRot = abs(rotVal)\n\n##############################################\n# Store final results\n##############################################\n\nnode\[\"maxX\"].setValue(maxX)\nnode\[\"maxY\"].setValue(maxY)\nnode\[\"maxRot\"].setValue(maxRot)\n\n# Get maximum absolute values\nmaxX   = abs(node\[\"maxX\"].value())\nmaxY   = abs(node\[\"maxY\"].value())\nmaxRot = abs(node\[\"maxRot\"].value())\n\n# Plate dimensions\nwidth  = node.width()\nheight = node.height()\n\n# Convert rotation to radians\ntheta = math.radians(maxRot)\n\n# Rotation-expanded bounding box\nrotW = abs(width  * math.cos(theta)) + abs(height * math.sin(theta))\nrotH = abs(height * math.cos(theta)) + abs(width  * math.sin(theta))\n\n# Add translation padding\nfinalW = rotW + 2 * maxX\nfinalH = rotH + 2 * maxY\n\n# Compute scaling\nscaleX = finalW / width\nscaleY = finalH / height\n\nrequiredScale = max(scaleX, scaleY)\n\n# Store result\nnode\[\"requiredScale\"].setValue(requiredScale)\n"}
 addUserKnob {7 maxX l "max x" +INVISIBLE R 0 50}
 maxX 5.72508
 addUserKnob {7 maxY l "max y" +INVISIBLE R 0 50}
 maxY 15.0973
 addUserKnob {7 maxRot l "max rot" +INVISIBLE}
 maxRot 0.001182686022
 addUserKnob {7 requiredScale l "post scale" t "How much to scale the image by post transform" R 0 4}
 requiredScale 1
 addUserKnob {6 postScaleEnable l enable -STARTLINE}
 postScaleEnable true
 addUserKnob {20 endGroup_5 n -1}
 addUserKnob {26 ""}
 addUserKnob {20 motionblur_1 l motionblur n 1}
 motionblur_1 0
 addUserKnob {41 motionblur T Transform1.motionblur}
 addUserKnob {41 shutter l Shutter T Transform1.shutter}
 addUserKnob {41 shutteroffset l "Shutter Offset" T Transform1.shutteroffset}
 addUserKnob {41 shuttercustomoffset l "" -STARTLINE T Transform1.shuttercustomoffset}
 addUserKnob {20 endGroup_3 n -1}
 addUserKnob {26 ""}
 addUserKnob {20 masterTranslation l "combined transform" +INVISIBLE n 1}
 addUserKnob {7 masterX l x R -50 50}
 masterX {{"baseline + (xAmpRaw*((xEnableLow?(xLowRaw(scaledFrame+timeOffset)*xLowAmp):0)+(xEnableMid?(xMidRaw(scaledFrame+timeOffset)*xMidAmp):0)+(xEnableHigh?(xHighRaw(scaledFrame+timeOffset)*xHighAmp):0)))" x1015 -5.5}}
 addUserKnob {7 masterY l y R -50 50}
 masterY {{"baseline + (yAmpRaw*((yEnableLow?(yLowRaw(scaledFrame+timeOffset)*yLowAmp):0)+(yEnableMid?(yMidRaw(scaledFrame+timeOffset)*yMidAmp):0)+(yEnableHigh?(yHighRaw(scaledFrame+timeOffset)*yHighAmp):0)))"}}
 addUserKnob {7 masterRot l rotation R -50 50}
 masterRot {{"baseline + (rotAmpRaw*((rotEnableLow?(rotLowRaw(scaledFrame+timeOffset)*rotLowAmp):0)+(rotEnableMid?(rotMidRaw(scaledFrame+timeOffset)*rotMidAmp):0)+(rotEnableHigh?(rotHighRaw(scaledFrame+timeOffset)*rotHighAmp):0)))"}}
 addUserKnob {20 endGroup_2 n -1}
 addUserKnob {26 _2 l "" +STARTLINE +INVISIBLE}
 addUserKnob {20 rawData l "raw data" +INVISIBLE n 1}
 rawData 0
 addUserKnob {7 xLowRaw l xLow}
 xLowRaw {{curve x1001 0}}
 addUserKnob {7 xMidRaw l xMid}
 xMidRaw {{curve x1001 0}}
 addUserKnob {7 xHighRaw l xHigh}
 xHighRaw {{curve x1001 0}}
 addUserKnob {26 _3 l "" +STARTLINE}
 addUserKnob {7 yLowRaw l yLow}
 yLowRaw {{curve x1001 0}}
 addUserKnob {7 yMidRaw l yMid}
 yMidRaw {{curve x1001 0}}
 addUserKnob {7 yHighRaw l yHigh}
 yHighRaw {{curve x1001 0}}
 addUserKnob {26 _5 l "" +STARTLINE +INVISIBLE}
 addUserKnob {7 rotLowRaw l rotLow}
 rotLowRaw {{curve x1001 0}}
 addUserKnob {7 rotMidRaw l rotMid}
 rotMidRaw {{curve x1001 0}}
 addUserKnob {7 rotHighRaw l rotHigh}
 rotHighRaw {{curve x1001 0}}
 addUserKnob {26 _1 l "" +STARTLINE}
 addUserKnob {20 endGroup_1 n -1}
 addUserKnob {26 _4 l "" +STARTLINE +INVISIBLE}
 addUserKnob {22 exportTransform l "export transform" t "Create a transform that exactly matches the result of the current settings.  This can be useful if you want to concatenate with other transforms.\n\nPost scale will be generated as a seperate transform if enabled." T "import nuke\n\nnode = nuke.thisNode()\n\n##############################################\n# 1. Collect ALL key times needed\n##############################################\n\nsource_knobs = \[\n    \"xLowRaw\", \"xMidRaw\", \"xHighRaw\",\n    \"yLowRaw\", \"yMidRaw\", \"yHighRaw\",\n    \"rotLowRaw\", \"rotMidRaw\", \"rotHighRaw\",\n    \"xAmpRaw\", \"yAmpRaw\", \"rotAmpRaw\",\n    \"xLowAmp\", \"xMidAmp\", \"xHighAmp\",\n    \"yLowAmp\", \"yMidAmp\", \"yHighAmp\",\n    \"rotLowAmp\", \"rotMidAmp\", \"rotHighAmp\",\n]\n\nkey_times = set()\n\ndef collect_times(kname):\n    if kname not in node.knobs():\n        return\n    k = node\[kname]\n    if not k.isAnimated():\n        return\n    for key in k.animation(0).keys():\n        key_times.add(key.x)\n\nfor kname in source_knobs:\n    collect_times(kname)\n\n# Also pick up master output keys (if they exist)\nfor m in \[\"masterX\", \"masterY\", \"masterRot\"]:\n    if m in node.knobs() and node\[m].isAnimated():\n        for key in node\[m].animation(0).keys():\n            key_times.add(key.x)\n\nif not key_times:\n    nuke.message(\"No animation to bake.\")\n    raise ValueError(\"No keys found\")\n\nkey_times = sorted(key_times)\n\n##############################################\n# 2. Create a Transform node OUTSIDE the group\n##############################################\n\nwith nuke.Root():\n    t = nuke.createNode(\"Transform\", inpanel=False)\n\n# Position near gizmo\nt.setXpos(node.xpos() + 100)\nt.setYpos(node.ypos())\nt.setName(\"SS_bakedTransform\")\n\n##############################################\n# 3. Ensure animation channels exist\n##############################################\n\n# translate: index 0 = x, 1 = y\nt\[\"translate\"].clearAnimated()\nt\[\"translate\"].setAnimated(0)\nt\[\"translate\"].setAnimated(1)\n\nt\[\"rotate\"].clearAnimated()\nt\[\"rotate\"].setAnimated(0)\n\n##############################################\n# 4. Helper eval function (respects expressions)\n##############################################\n\ndef eval_knob(kn, tval):\n    k = node\[kn]\n    if hasattr(k, \"getValueAt\"):\n        return k.getValueAt(tval)\n    return k.value()\n\n##############################################\n# 5. Bake ALL subframe keys\n##############################################\n\nfor time in key_times:\n\n    x = eval_knob(\"masterX\", time)\n    y = eval_knob(\"masterY\", time)\n    r = eval_knob(\"masterRot\", time)\n\n    # Write keys\n    t\[\"translate\"].setValueAt(x, time, 0)\n    t\[\"translate\"].setValueAt(y, time, 1)\n    t\[\"rotate\"].setValueAt(r, time)\n\n##############################################\n# Copy requiredScale from gizmo to Transform\n##############################################\n\nif node\['postScaleEnable']:\n\n    with nuke.Root():\n        t2 = nuke.createNode(\"Transform\", inpanel=False)\n\n    src = node\[\"requiredScale\"]\n    dst = t2\[\"scale\"]   # the scale knob on the new Transform\n\n    t2.setName(\"SS_postScale\")\n\n    # CASE 1 — Static value (no animation curve)\n    if not src.isAnimated():\n        dst.clearAnimated()          # ensure destination is not animated\n        dst.setValue(src.value())    # simple static copy\n\n    # CASE 2 — Animated curve\n    else:\n        # Prepare destination for animation\n        dst.clearAnimated()\n        dst.setAnimated(0)  # scale has index 0\n        curve = src.animation(0)\n\n        # Copy keys (preserve sub-frame)\n        for key in curve.keys():\n            dst.setValueAt(key.y, key.x, 0)\n\n\n\n##############################################\n# Baked transform complete\n##############################################\n" +STARTLINE}
 addUserKnob {20 about l Info}
 addUserKnob {26 aboutText l "" +STARTLINE T "Copyright Stephen Newbold - 2026<p>\n<a href=\"https://github.com/stevenewbold/ShakeSynth\" style=\"color:#FFFFFF\">https://github.com/stevenewbold/ShakeSynth</a><p>\nThe companion iOS app can be found on the Apple AppStore."}
}
 CheckerBoard2 {
  inputs 0
  format "1280 720 0 0 1280 720 1 HD_720"
  boxsize 32
  name CheckerBoard1
  xpos 116
  ypos -144
 }
 Input {
  inputs 0
  name Input1
  xpos -69
  ypos -217
 }
 Switch {
  inputs 2
  which {{preview}}
  name Switch1
  xpos -69
  ypos -120
 }
 Transform {
  translate {{masterX} {masterY}}
  rotate {{masterRot}}
  center {{width/2} {height/2}}
  motionblur 1
  name Transform1
  xpos -69
  ypos -70
 }
 Grade {
  black_clamp false
  name BreakConcat
  xpos -69
  ypos -34
 }
 Transform {
  scale {{requiredScale}}
  center {{width/2} {height/2}}
  name Transform2
  xpos -69
  ypos -3
  disable {{!postScaleEnable}}
 }
 Output {
  name Output1
  xpos -69
  ypos 54
 }
end_group
